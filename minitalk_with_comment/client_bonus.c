#include "minitalk_bonus.h"

// Мы принимаем строку - её надо "раздробить" на символы, 
// и каждый символ перевести в 0 и 1, и отправить сигналами.
// Важно помнить, что надо посылать сигнал только после отклика от сервера!

volatile sig_atomic_t	g_response = 0;
// Фиксатор отклика от сервера - одновременно для функций 1) и 2)
// (так как глобальная переменная).

// 1) Функция, которая ПРИНИМАЕТ отклик от сервера 
// - либо всё ОК и работаем дальше, либо ошибка и end.
static void rec_serv_response(int signum)
{
    (void)signum;
	g_response = 1; // принимаем сигнал и меняем из-за этого флаг
}

// 2) Функция, которая отвечает за ожидание от сервера отклика, что сигнал принят.
static int wait_response(void)
{ // сидим в вечном ожидании ответного сигнала от сервера, что
    while (g_response != 1) // фиксируем сменой флага
    {
	}
	g_response = 0; 
	return (1);
}

// Функция, которая анализирует строку, и отправляет 
// каждый символ в виде двоичных сигналов.
static void send_string(int pid, char *string)
{
    int                 i;      // Счетчик до конца сообщения;
    int                 num;    // Число символов в сообщении;
    int                 count;  // Это наше 128, которое мы 'режем' до нуля;
    struct sigaction	receiv; // Структура на прием сигналов от сервера, 
                                // чтобы знать, когда подавать новый сигнал.
   
    i = 0;
    num = ft_strlen(string);
    receiv.sa_flags = 0;                    // 0 значит 1 параметр в функции ниже. 
	receiv.sa_handler = rec_serv_response;  // Функция, которая принимает и обрабатывает внешние сигналы
                                            // (от сервера).
    if (sigaction(SIGUSR1, &receiv, 0) == -1 || sigaction(SIGUSR2, &receiv, 0) == -1)
		alert("Ошибка при отпраке сигнала!", 0); // 3.
    
    // Перебираем поданную строку. 
    while (i <= num)
    {
        count = 128; // в int это '1.0.0.0.0.0.0.0.'
        while(count != 0) // мы смещаем до тех пор, пока не наткнемся на ноль
        {
            if (string[i] & count) // Логическое умножение
            {
                if (kill(pid, SIGUSR1) == -1) // Посылаем на сервер '1'.
                    alert("Ошибка функции kill!", 0); // 4.
            }
            else
            {
                if (kill(pid, SIGUSR2) == -1) // Посылаем на сервер '0'.
                    alert("Ошибка функции kill!", 0); // 4.
            }

            count = count >> 1; // Смещаем '1', на одну позицию вправо: теперь это '0.1.0.0.0.0.0.0.'.
            wait_response(); // Функция, которая ждет отклика от сервера, прежде чем посылать новый сигнал.
        }
        i++;
    }
}

// Тут подается две переменные - (1) номер сервера (PID), (2) и непосредственно сама строка.
// Если больше или меньше - то посос - "wrong input".
// В случае (1) надо проверить что подано именно число - делаем это через atoi;
// В случае (2) мы просто каждый символ в отдельности посылаем в ф., которая его разобъёт на 0 и 1.
int main(int argc, char *argv[])
{
    int pid;

    if (argc != 3)
        alert ("Wrong input!", 0); // 5.

    pid = ft_atoi(argv[1]);
    if (!pid)                 
        alert ("Wrong PID!", 0); // 5.
    send_string(pid, argv[2]);
}
